package ReflectionAPI{import flash.display.*;import flash.geom.Matrix;
	/**
* @author andrehines
*/
public class Reflection{		function Reflection(){		trace("Reflection class instantiated");		}		// reflects a passed in DisplayObject and returns 2 masks and 2 DisplayObjects	public static function reflect(theDO:Sprite, theAlphas:Array, theRatios:Array, reflectionOffset:Number = 0, scaleX:Number = 1, scaleY:Number = 1):Object{		trace("reflect function called");				//duplicate the DO		var theBMD:BitmapData = new BitmapData(theDO.width, theDO.height, true, 0x00FF0000);		theBMD.draw(theDO);		var reflectionBMP:Bitmap = new Bitmap(theBMD);		reflectionBMP.smoothing = true;		var reflection:MovieClip = new MovieClip();		reflection.addChild(reflectionBMP);				theDO.scaleX = reflection.scaleX = scaleX;		theDO.scaleY = scaleY;		reflection.scaleY = -scaleY;				//add to display list and rotate		reflection.y = theDO.y + ((2 * reflection.height) + reflectionOffset);		reflection.x = theDO.x;		theDO.parent.addChildAt(reflection, theDO.parent.getChildIndex(theDO));				//add to returned object		var returnedObj:Object = new Object();		returnedObj.reflectionOffset = reflectionOffset;		returnedObj.original = theDO;		returnedObj.reflection = reflection;		returnedObj.reflectionOrigX = reflection.x;		returnedObj.reflectionOrigY = reflection.y;		returnedObj.originalOrigX = theDO.x;		returnedObj.originalOrigY = theDO.y;				//now create a mask for each		var maskBMD:BitmapData = new BitmapData(theDO.width, theDO.height + theDO.stage.stageHeight, false, 0xFF0000);		var originalMask:Bitmap = new Bitmap(maskBMD);		var reflectionMask:Sprite = new Sprite();				var fillType:String = GradientType.LINEAR; 		var colors:Array = new Array();		for (var i:Number = 0; i < theAlphas.length; i++) colors.push(0xFFFFFF); 		//we create a matrix because we are going to have to rotate the gradient		var matrix:Matrix = new Matrix();		matrix.createGradientBox(theDO.width, theDO.height, (90 / 180) * Math.PI, 0, 0); 		reflectionMask.graphics.beginGradientFill(GradientType.LINEAR, colors, theAlphas, theRatios, matrix);		reflectionMask.graphics.drawRect(0, 0, theDO.width, theDO.height);		reflectionMask.cacheAsBitmap = true;		reflection.cacheAsBitmap = true;				//now place the masks over their counterparts		originalMask.x = theDO.x;		originalMask.y = theDO.y - theDO.stage.stageHeight;		theDO.mask = originalMask;				reflectionMask.x = reflection.x;		reflectionMask.scaleY = -1;		reflectionMask.y = reflection.y;		reflection.mask = reflectionMask;				//add to display list and rotate		theDO.parent.addChild(originalMask);		theDO.parent.addChild(reflectionMask);				//add to returned object		returnedObj.originalMask = originalMask;		returnedObj.reflectionMask = reflectionMask;				return returnedObj;	}}}