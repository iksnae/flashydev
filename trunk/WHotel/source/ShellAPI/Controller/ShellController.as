package ShellAPI.Controller {	import ShellAPI.Controller.ShellControllerAbstract;	import ShellAPI.Model.ShellModel;	import ShellAPI.Factories.XMLSimpleFactory;	import ShellAPI.View.ShellView;	import ShellAPI.Events.*;		import flash.utils.*;	import flash.net.URLRequest;	import flash.display.Loader;	import flash.events.*;		import fl.transitions.Tween;	import fl.transitions.TweenEvent;	import fl.transitions.easing.*;		import events.XMLEvent;		/** * @author andrehines */public class ShellController extends ShellControllerAbstract {		function ShellController(){		trace("ShellController class instantiated");				//create the Model    	__theModel = new ShellModel();    	    	//create the DEFAULT xml behavior, this can be programmed to be changed dynamically    	this.__theXMLFactory = new XMLSimpleFactory();    	this.__theXMLBehavior = this.__theXMLFactory.createBehavior(this.__targetXMLType, this.__targetXMLURL);			//make sure the View knows the Model		this.__theView = new ShellView();		this.__theView.theModel = this.__theModel;		this.__theView.setup();				//setup Listeners		setupListeners();				//now load shell info		this.__theXMLBehavior.execute();		}		// sets up the load animation MovieClip	override protected function setupLoadAnimation():void{		trace("setupLoadAnimation function called on: " + getQualifiedClassName(this));				this.__loadStartingX = this.__loadAnimationMC.x;		this.__loadStartingY = this.__loadAnimationMC.y;				//make sure the load is not visible initially, unless it is loading something by call		//of getSection method		this.__loadAnimationMC.alpha = 0;	}		//sets up listeners	override protected function setupListeners():void{		trace("setupListeners function called on: " + getQualifiedClassName(this));					this.__theXMLBehavior.addEventListener(XMLEvent.PACKAGED_INFO, onPackagedInfo, false)	}		//retrieves the info from the model and loads that particular section in	override public function getSection(sectionType:String = "Carousel", sectionIndex:uint = 0):void{		trace("getSection function called on: " + getQualifiedClassName(this));				var theSections:Array = this.__theModel.sections;		//trace("theSections: " + theSections);				//iterate and find the index with the matching sectionType		for(var i in theSections){			if(theSections[i].type == sectionType){				//now check for the index that corresponds to the passed in target index to load				//and also populate into the model, but first check if we already				//have this section loaded				var theURL:String = theSections[i][sectionIndex].swfURL;								if(this.__theModel.currentSection != null){					if(theURL == this.__theModel.currentSection.swfURL){						return;					}				}				//first we remove any previous sections				removeSection();								this.__theModel.currentSection = theSections[i][sectionIndex];												//call function to broadcast currentSectionType changed				if(this.__theModel.currentSectionType != theSections[i].type){					this.__theModel.currentSectionType = theSections[i].type;					onSectionTypeChanged();				}								break;			}		}				//now we prepare to load the section into the view		__theLoader = new Loader();		this.__theModel.currentLoader = this.__theLoader;		setupContentLoaderInfoListeners(this.__theLoader.contentLoaderInfo);				__theURLRequest = new URLRequest(theURL);        this.__theLoader.load(this.__theURLRequest);        this.__theView.addChild(this.__theLoader);	}		// removes the section	override public function removeSection():Boolean{		trace("removeSection function called on: " + getQualifiedClassName(this));				if(this.__theModel.currentSection != null){			this.__theLoader.unload();			this.__theModel.currentSection = null;						return true;		}else{			return false;		}	}		//configures event handling for the contentLoaderInfo dispatcher	protected function setupContentLoaderInfoListeners(theDispatcher:IEventDispatcher):void{		trace("setupContentLoaderInfoListeners function called on: " + getQualifiedClassName(this));				theDispatcher.addEventListener(Event.COMPLETE, onLoadComplete);       // theDispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);        //theDispatcher.addEventListener(Event.INIT, initHandler);        //theDispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);        theDispatcher.addEventListener(Event.OPEN, onLoadStart);        theDispatcher.addEventListener(ProgressEvent.PROGRESS, onLoadProgress);        //theDispatcher.addEventListener(Event.UNLOAD, unLoadHandler);			}		// removes loadingAnimationMC	override public function removeLoadAnimation():void{		trace("removeLoadAnimation function called on: " + getQualifiedClassName(this));				if(this.__loadTweenY == null){			this.__loadTweenY = new Tween(this.__loadAnimationMC, "y", Back.easeOut, this.__loadAnimationMC.y, this.__loadStartingY + this.__loadAnimationMC.height, .7, true);			this.__loadTweenAlpha = new Tween(this.__loadAnimationMC, "alpha", Strong.easeOut, this.__loadAnimationMC.alpha, 0, .5, true);		}else{			this.__loadTweenY.continueTo(this.__loadStartingY + this.__loadAnimationMC.height, .7);			this.__loadTweenAlpha.continueTo(0, .5);		}	}		// reveals loadingAnimationMC	override public function revealLoadAnimation():void{		trace("revealLoadAnimation function called on: " + getQualifiedClassName(this));				if(this.__loadTweenY == null){			this.__loadTweenY = new Tween(this.__loadAnimationMC, "y", Back.easeOut, this.__loadAnimationMC.y, this.__loadStartingY, .7, true);			this.__loadTweenAlpha = new Tween(this.__loadAnimationMC, "alpha", Strong.easeOut, this.__loadAnimationMC.alpha, 100, .5, true);		}else{			this.__loadTweenY.continueTo(this.__loadStartingY, .7);			this.__loadTweenAlpha.continueTo(100, .5);		}	}		// broadcasts that a section type has changed	override public function onSectionTypeChanged():void{		trace("onSctionTypeChanged function called on: " + getQualifiedClassName(this));				dispatchEvent(new ShellEvent(ShellEvent.SECTION_TYPE_CHANGED, false, false, this.__theModel.currentSectionType));	}			///////////////////////////////////// EVENTS ///////////////////////////////////////////////////		// EVENT handles setting up the view when our XML info is loaded and packaged	override public function onPackagedInfo(eventObj:XMLEvent):void{		trace("onPackagedInfo event caught on: " + getQualifiedClassName(this));				//attach the view		this.addChild(this.__theView);				//populate the model with the packaged info		this.__theModel.sections = eventObj.packagedInfo;				//also broadcast that we have packaged info		dispatchEvent(new XMLEvent(XMLEvent.PACKAGED_INFO));	}		// EVENT handles making the loading animation visible whenever loading starts	override public function onLoadStart(eventObj:Event):void{		trace("onLoadStart event caught on: " + getQualifiedClassName(this));				revealLoadAnimation();	}		// EVENT handles making the loading animation invisible whenever loading completes	override public function onLoadComplete(eventObj:Event):void{		trace("onLoadComplete event caught on: " + getQualifiedClassName(this));				removeLoadAnimation();				//dispatch		dispatchEvent(new Event(Event.COMPLETE, false));	}		// EVENT handles calling the currentPercentage function on the loading animation MovieClip	override public function onLoadProgress(eventObj:ProgressEvent):void{		trace("onLoadProgress event caught on: " + getQualifiedClassName(this));				this.__loadAnimationMC.currentPercentage = Math.round((eventObj.bytesLoaded / eventObj.bytesTotal) * 100);	}	}}